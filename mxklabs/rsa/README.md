## <a name="mxklabs.data">Module mxklabs.data
A work-in-progress python 3 module for decoding `openssh` RSA certificates (the certificates generated by `ssh-keygen` with default settings on Ubuntu 18.04). Note that currently only keys without a passphrase are supported. Older file formats are also not supported.

### Installation
```sh
pip install mxklabs
```

### RsaUtils: Example
Convert a private or public key file into a dictionary.

```python
import mxklabs.rsa as mxkrsa

# Decode the key files.
id_rsa = mxkrsa.RsaUtils.private_key_from_file('id_rsa')
id_rsa_pub = mxkrsa.RsaUtils.public_key_from_file('id_rsa.pub')

print(id_rsa)
print(id_rsa_pub)
```

### RsaBenchmarkRepository: Example
Load some benchmarks you can use to compare your integer factorisation functions. 

```python
import mxklabs.rsa as mxkrsa

# Instantiate the benchmark repository.
repo = mxkrsa.RsaBenchmarkRepository()

# Print out the benchmarks.
for benchmark in repo:
  print('-'*80)
  print(f"  id={benchmark.id}")
  print(f"  modulus={benchmark.modulus} ({benchmark.modulus.bit_length()} bits)")
  print(f"  prime1={benchmark.prime1} ({benchmark.prime1.bit_length()} bits)")
  print(f"  prime2={benchmark.prime2} ({benchmark.prime2.bit_length()} bits)")
```

The idea is that you try and factorise `modulus` into prime factors. The prime factors, `prime1` and `prime2` are also included in the benchmark for verification purposes.

Note that the benchmark repository includes at least one modulus with bit-length *n* for all even *n* in [8, 2048] and, as per `OpenSSH` keys, the bit length of both primes is always *exactly
half* that of the modulus.

### RsaEvalTool: Example
Use our tool to see how your factorisation algorithm performs over
benchmarks of increasing bit lengths. Any call taking longer than 
a specified timeout will automatically be terminated because our
evaluation tool runs your function in a separate process.

```python
import mxklabs.rsa as mxkrsa
import matplotlib.pyplot as plt

def naive_factorisation(modulus, callback):
  """ Replace this with your state-of-the-art implementation. """
  for p in range(3,modulus):
    if modulus % p == 0:
      result = p
      # Once you have found the factors, return by calling the
      # callback with the first argument being the prime factor
      # you found and the second argument being a dictionary of
      # diagnostic values you want to keep track of (see below).
      return callback(result, {'number-of-iterations': p - 3 + 1})

# Do the evaluation over a bunch of benchmarks.
eval_tool = mxkrsa.RsaEvalTool()
results = eval_tool.evaluate(naive_factorisation, timeout=10, verbose=True)

# Get the results as lists of values.
benchmark_ids = results.get_values('benchmark-id')
moduli = results.get_values('modulus')
moduli_sqrts = results.get_values('modulus-sqrt')
moduli_bit_lengths = results.get_values('modulus-bit-length')
run_times = results.get_values('run-time')
# You can get your custom values back here.
num_iterations = results.get_values('number-of-iterations')

# Plot the results.
plt.title('Results for \'Naive Factorisation Function\'')
plt.scatter(moduli_bit_lengths, run_times, marker='+', label='modulus bit length vs run time')
```

If your algorithm gets to the 2048-bit benchmark come and find me -- I'll buy you a Twix.

### RsaUtils: API Summary

| Object | Type |
|---|---|
| [`mxklabs.rsa.RsaUtils`](#mxklabs.rsa.RsaUtils) [[`link`](#mxklabs.rsa.RsaUtils)] | `object` |
| [`mxklabs.rsa.RsaUtils.private_key_from_file`](#mxklabs.rsa.RsaUtils.private_key_from_file) [[`link`](#mxklabs.rsa.RsaUtils.private_key_from_file)] | `function` |
| [`mxklabs.rsa.RsaUtils.public_key_from_file`](#mxklabs.rsa.RsaUtils.public_key_from_file) [[`link`](#mxklabs.rsa.RsaUtils.public_key_from_file)] | `function` || [`mxklabs.rsa.RsaUtils.public_key_from_file`](#mxklabs.rsa.RsaUtils.public_key_from_file) [[`link`](#mxklabs.rsa.RsaUtils.public_key_from_file)] | `function` |
| [`mxklabs.rsa.RsaBenchmark`](#mxklabs.rsa.RsaBenchmark) [[`link`](#mxklabs.rsa.RsaBenchmark)] | `object` | 
| [`mxklabs.rsa.RsaBenchmarkRepository`](#mxklabs.rsa.RsaBenchmarkRepository) [[`link`](#mxklabs.rsa.RsaBenchmarkRepository)] | `object` |


#### <a name="mxklabs.rsa.RsaUtils"></a> `mxklabs.rsa.RsaUtils`
There is no need to instantiate `RsaUtils` at the moment because all it's methods are static.

#### <a name="mxklabs.rsa.RsaUtils.private_key_from_file"></a> `mxklabs.data.rsa.RsaUtils.private_key_from_file(self, filename)`
Takes the name of a private key filename and produces a dictionary with the following fields: `coefficient`, `exponent1`, 
 `exponent2`, `modulus`, `prime1`, `prime2`, `privateExponent`, 
 `publicExponent` and `version`.

#### <a name="mxklabs.rsa.RsaUtils.public_key_from_file"></a> `mxklabs.data.rsa.RsaUtils.public_key_from_file(self, filename)`
Takes the name of a public key filename and produces a dictionary with the following fields: `modulus`, `publicExponent`.

#### <a name="mxklabs.rsa.RsaBenchmark"></a> `mxklabs.rsa.RsaBenchmark`
An <a name="mxklabs.rsa.RsaBenchmark">`RsaBenchmark`</a> object represents an RSA integer factorisation challenge and is an object with the following attributes:

| Object | Type | Description |
|---|---|---|
| id | 'string' | A unique identifier. |
| modulus | 'int' | The RSA modulus. |
| prime1 | 'int' | The smallest prime factor of the modulus. | 
| prime2 | 'int' | The largest prime factor of the modulus. | 

a string attribute `id` and integer attributes `modulus`, `prime1` and `prime2` representing a benchmark RSA certificate of a certain bit length. The integers have the following properties:
* `prime1` and `prime2` are prime numbers
* `prime1` is less than or equal to `prime2`
* `modulus` equals `prime1*prime2`
* `modulus.bit_length()` equals `2*prime1.bit_length()`
* `modulus.bit_length()` equals `2*prime2.bit_length()`

As an end-user, you don't instantiate <a name="mxklabs.rsa.RsaBenchmark">`RsaBenchmark`</a> objects yourself; you obtain them via a <a name="mxklabs.rsa.RsaBenchmarkRepository">`RsaBenchmarkRepository`</a> instance.

#### <a name="mxklabs.rsa.RsaBenchmarkRepository"></a> `mxklabs.rsa.RsaBenchmarkRepository`
You can instantiate <a name="mxklabs.rsa.RsaBenchmarkRepository">RsaBenchmarkRepository</a> without any argument and subsequently use it as an iterator over <a name="mxklabs.rsa.RsaBenchmark">`RsaBenchmark`</a> instances of increasing difficulty.